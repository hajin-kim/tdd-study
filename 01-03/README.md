# 1장. 다중 통화를 지원하는 Money 객체

### 다중 통화를 지원하는 보고서

- 보고서를 생성하기 위해 어떤 기능이 있어야 할까?
- == 어떤 테스트들이 있어야 보고서에 제대로 계산되도록 하는 코드가 완성됐다는걸 확신할 수 있을까?
    1. 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
    2. 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

이를 위해 앞으로 어떤 일을 해야 할지 알려주고, 지금 하는 일에 집중할 수 있게 하는 할일 목록을 작성해보자.

### 할일 목록

> $5 + 10CHF = $10 (환율이 2:1일 경우)
**$5 x 2 = $10**
>

---

할일 목록의 곱하기를 먼저 다루자.
그럼 어떤 객체가 있어야 할까?

객체를 만들면서 시작하는게 아닌 **테스트를 먼저** 만들어야 한다.

그렇다면, 어떤 테스트가 필요할까?

첫 번째 테스트는 복잡해보인다. 작은 것부터 시작하던지, 복잡하지 않은 두번째부터 다뤄보자.

## 5단계 테스트 주기

### 1. 테스트를 작성할 때는 오퍼레이션(메서드)의 완벽한 인터페이스에 대해 상상해보자.

- 오퍼레이션이 외부에서 어떤 식으로 보일지에 대한 이야기를 테스트코드에 적는것

```java
public void testMultiplication() {
	Dollar five = new Dollar(5);
	five.times(2);
	assertEquals(10, five.amount);
```

- (위 코드는 공용 필드 및 금액 계산에 정수형을 사용하고 예기치 못한 부작용이 있을 수 있다. 하지만 작은 단계부터 시작하는것이 우선, 이런 문제들을 할일 목록에 적어놓고 계속 진행하자. 우리에겐 실패하는 테스트가 주어진 상태고, 빨리 초록 막대를 보고싶은 상황이다.)
- 업데이트된 할일 목록

> $5 + 10CHF = $10 (환율이 2:1일 경우)
**$5 x 2 = $10**
amount를 private로 만들기 (new!)
Dollar 부작용 (side effect)? (new!)
Money 반올림? (new!)
>

### 2. 방금 작성한 테스트를 컴파일이 되도록 만들자.

- 4개의 컴파일 에러가 있다.
    - Dollar 클래스가 없음
    - 생성자가 없음
    - times(int) 메서드가 없음
    - amount 필드가 없음

한 번에 하나씩 에러를 없애보자.

- 3. times() 메서드는 스텁 구현이 필요하다. 컴파일만 될 수 있게 최소한의 구현만 해보자.
    - 스텁이란? 메서드의 서명부와 반환값이 있을 경우 반환 명령만 적어, 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것.

```java
class Dollar { //1. Dollar 클래스 생성

	int amount; //4. amount 필드 추가

	Dollar(int amount) { //2.생성자 추가. 안에서는 아무 일도 안 해도 된다. 
			
	}

	void times(int multiplier) { //3. times(int) 메서드 스텁 생성

	}
```

오예! 이제 컴파일이 되고 테스트를 실행해서 테스트가 실패하는 모습을 볼 수 있다.

우리는 지금 “빨간 막대”를 보고 있고, 테스트를 실행하면 결과로 ‘10’이 아닌 ‘0’이 나오는 것을 볼 수 있다.

이를 통해 실패에 대한 구체적인 척도를 갖게 되었고, 우리의 문제는
‘다중 통화 구현’ → ‘이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기’ 로 변형되었다.

이는 훨씬 간단하고 적은 범위이며, 이 테스트를 통과시키는 건 쉽다.

당장의 목표는 이 테스트를 통과시키는 것이다.  어떻게 할 수 있을까?

### 3. 테스트를 통과시키기 위해 조금 수정을 거친다.

```java
class Dollar { 

	int amount = 10;  //amount = 10으로 설정

	Dollar(int amount) { 
	}

	void times(int multiplier) { 
	}
```

- 테스트 코드의 five.amount 가 10이 될 수 있게 amount에 10을 할당해주었다.

### 4. 테스트를 실행해서 테스트가 성공하는 것을 확인한다.

- 수정을 통해 테스트가 성공하고, 초록 막대를 볼 수 있다. ~~(오, 이 환희!…)~~
- 하지만 위와 같이 제한적이고 단순한 구현을 통과시켜줄 만한 입력값은 찾기 힘들다.

계속 진행하기 전에 **“일반화”** 를 해야 한다.

<aside>
🕰️ 테스트 주기는 다음과 같다. 우리는 현재 4단계까지 수행했다.

1. 작은 테스트를 하나 추가한다. `(testMultiplication())`
2. 모든 테스트를 실행해서 테스트가  실패하는 것을 확인한다. `컴파일, assertEqual(10,0)`
3. 조금 수정한다.  `(amount = 10)`
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다. `assertEqual(10,10)`
5. **중복을 제거하기 위해 리팩토링을 한다.**
    - 리팩토링이란? 코드의 외적 행위는 유지하면서 내부 구조를 변경하는 작업.
</aside>

> 의존성과 중복

문제 : 테스트와 코드 사이에 존재하는 의존성

코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다.

하지만 우리의 목표는 코드를 바꾸지 않으면서도 의미 있는 테스트를 하나 더 작성하는 것이다.

의존성이 문제 그 자체라면 중복은 문제의 징후다. 가장 흔한 예로는 로직의 중복이다. 그리고 중복된 로직을 하나로 끄집어내기 위해서는 객체를 이용하는 것이 최고다.

프로그램에서는 중복만 제거해 주면 의존성도 제거된다.

이 것이 TDD의 두 번째 규칙 (중복을 제거해라) 이 존재하는 이유다. 다음 테스트로 진행하기 전에 중복을 제거함으로서, 오직 한가지의 코드 수정(one and only once: 필요한 것을 하되 단 한번만 하라.) 을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 하는 것이다.

---

### 5. 중복을 제거하기 위해 리팩토링을 한다.

- 어디가 중복인 것일까?
    - **테스트에 있는 데이터**와 **코드에 있는 데이터 사이**의 중복 (`five.amount` &  `int amount = 10`)
    - `int amount = 5 * 2` (즉, 10) 코드를 다음과 같이 썼다면 어땠을까?
    - 여기에서 10은 다른 어딘가에서 넘어온 값이다. 이제 5와 2가 두 곳에 존재하고, 이 중복을 제거해야 한다.
    - 5와 2를 한 번에 제거할 수 있는 방법은 없다.
    - **객체의 초기화 단계에 있는 설정 코드를 times() 메서드 안으로 옮겨보자!**

```java
class Dollar { 

    int amount = 10;
    
    Dollar(int amount) { 
    }
    
    void times(int multiplier) { 
        **amount = 5 * 2; // times 메서드 안에서 amount를 할당해준다.** 
    }
```

테스트 코드와 작업 코드 사이의 중복을 마저 드러내보자.

- 5를 어디서 얻을 수 있을까?
    - 5는 생성자에서 넘어오는 값인걸 우리는 알고있다.
    1. **이를 amount 변수에 저장해보자!**
    2. 넘어온 amount 값을 times에서 사용하도록 변경하자.
    3. 인자 multiplier의 값이 2이므로, 상수를 인자로 대체할 수 있다.
    4. 최종적으로 자바 문법을 활용해 중복을 제거하자.

```java
class Dollar {

    int amount = 10;

    Dollar(int amount) {
        this.amount = amount; //1. amount 변수에 생성자로 넘어온 값을 저장**
    }

    void times(int multiplier) {
        amount = 5 * 2;
        amount = amount * 2; // 2. 넘어온 amount 값을 times() 에서 사용하도록 변경
        amount = amount * multiplier; //3. 인자 multiplier 의 값이 2이므로, 상수를 인자로 대체
        amount *= multiplier; //4. 최종 중복 제거**
    }
}
```

- 돌아가는 코드에서 상수 → 변수로 변경하여 점진적으로 일반화를 했다.
- 이제 첫 번째 테스트 ($5 x 2 = $10) 에 완료 표시를 할 수 있게 됐다. 다음 할일 목록으로 넘어가보자.

---

# 2장. 타락한 객체

### 일반적인 TDD 주기

1. 테스트를 작성: 마음속의 오퍼레이션(메서드)이 코드에 어떤 식으로 나타나길 원하는지 적기
2. 실행 가능하게 만들기
    1. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력
    2. 그것이 구현하는데 몇 분 정도 걸린다면 일단 적어놓은 후 초록 막대를 보는 것으로 돌아오기
3. 올바르게 만들기
    1. 직전에 저질렀던 죄악들을 수습하기:  중복을 제거하고 초록 막대로 되돌리기

### 우리의 목표:

- “작동”하는 “깔끔”한 코드를 얻는 것. “작동하는” 에 해당하는 부분을 먼저 해결하자.

### - **Dollar 부작용 (side effect)**

**할일 목록**

> $5 + 10CHF = $10 (환율이 2:1일 경우)
> 
> ~~$5 x 2 = $10~~
> 
> amount를 private로 만들기
> 
> **Dollar 부작용 (side effect)?**
> 
> Money 반올림?

다시 할 일 목록을 보자. 1장에서 테스트를 통과했지만, 이상한 부분이 있다.

**Dollar에 대해 연산을 수행한 후에 해당 Dollar의 값이 바뀌는 점**이다.

테스트 코드를 다시 작성해보자.

```java
public void testMultiplication() {
	Dollar five = new Dollar(5);
	five.times(2);
	assertEquals(10, product.amount);
	five.times(3);
	assertEquals(15, product.amount);
```

- 하지만 이 테스트는 통과하지 않는다. times()를 처음 호출한 이후 five는 더 이상 5가 아니기 때문이다.

**→ times() 에서 새로운 객체를 반환**하게 한다면 어떨까?

- 이를 위해 Dollar 인터페이스와 테스트를 수정해보자.

Step 1: 테스트 작성

```java
public void testMultiplication() {
	Dollar five = new Dollar(5);
	Dollar product = five.times(2);
	assertEquals(10, product.amount);
	product =	five.times(3);
	assertEquals(15, product.amount);
```

Step 2: 이제 컴파일이 되게 하기 위해 Dollar.times()를 수정해보자. 하지만 실행되지는 않는다.

기존 코드

```java
void times(int multiplier) {
	amount *= multiplier;
}
```

수정한 코드

```java
Dollar times(int multiplier) {
	amount *= multiplier;
	return null;
}
```

Step 3: 테스트를 통과시키기 위해 올바른 금액을 갖는 새 Dollar를 반환하도록 만든다.

```java
Dollar times(int multiplier){
        return new Dollar(amount*multiplier);
}
```

테스트가 통과한다.

---

1장에서는 테스트를 통과하기 위해 가짜 구현으로 시작해서 점차 실제 구현을 만들어갔다.

하지만 이번에는 올바른 구현이라고 생각한 내용을 입력했다.

### **최대한 빨리 테스트를 통과하기 위한 전략 2가지**

1. 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸기 (1장)
2. 명백한 구현 사용하기: 실제 구현을 입력한다. (2장)
- 두 가지 방법을 번갈아 사용하자.
- 내가 뭘 입력해야 할지 알 때는 명백한 구현을 더해 나가고, 예상치 못한 실패를 한다면 가짜로 구현하기 방법을 사용해 올바른 코드로 리팩토링한다.
3. 삼각측량 사용 (3장 tbc)

---

**Summary**

- 설계상의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다. (Step 1)
- 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.  (Step 2)
- 올바르다고 생각하는 코드를 입력해 테스트를 통과했다. (Step 3)

---

# 3장. 모두를 위한 평등

**Introduction**

- 우리는 어떤 정수에 1을 더했을 때 원래 정수가 변할 거라고 예상하지 않는다. 원래 정수에 1이 더해진 새로운 값을 갖게 될 것으로 예상한다.
- 지금까지 Dollar 객체같이 객체를 값처럼 쓸 수 있는 패턴을 Value Object 패턴이라고 한다.
    - **제약사항**: 객체의 인스턴스 변수가 생성자를 통해서 설정된 후에는 결코 변하지 않는다
    - 별칭 문제를 걱정할 필요가 없는 장점이 있다.
    - 모든 연산은 새 객체를 반환해야 한다는 것을 암시한다.
    - 또한 값 객체는 equals() 를 구현해야 한다는 것을 암시한다. 할일 목록에 추가하자.
    - Dollar를 hash table의 key로 사용한다면 hashCode() 도 같이 구현해야한다. 일단 할일 목록에 적어놓고 나중에 문제가 생기면 그때 다루도록 하자.


**할일 목록**

> $5 + 10CHF = $10 (환율이 2:1일 경우)$5 x 2 = $10
> 
> amount를 private로 만들기
> 
> Dollar 부작용 (side effect)?
> 
> Money 반올림?
> 
> equals() (new!)
> 
> hashCode() (new!)

### - Equals()

1장에서와 같이 5단계 테스트 주기를 따라가보자.

1. equals() 를 해결하기 위해 테스트를 작성해보자.

```java
public void testEquality() {
	assertTrue(new Dollar(5).equals(new Dollar(5)));
}
```
2. *컴파일이 되도록 equals() 껍데기 메서드를 작성한다. (책에서는 생략)*
3. 테스트가 실패한다. 가짜로 구현하는 방법인 단순히 true를 반환하도록 equals() 메서드를 작성해보자.

```java
public boolean equals(Object object) {
	return true;
}
```

4. 테스트를 통과한다.
5. 삼각측량을 이용해 코드를 일반화해보자.
    1. 이를 이용한 일반화는 두 개 이상의 예제를 필요로 한다.
    2. 테스트 코드와 모델 코드 사이의 중복을 잠시 무시하고, 두 번째 예제가 좀 더 일반적인 해를 필요로 할 때 비로소 일반화한다.

- **두 번째 예제 : $5 ≠ $6**
- 테스트에 두 번째 예제를 추가했다.

```java
public void testEquality() {
	assertTrue(new Dollar(5).equals(new Dollar(5)));
	**assertTrue(new Dollar(5).equals(new Dollar(6)));**
```

- 이제 동치성(equality) 를 일반화해보자.

```java
public boolean equals(Object object) {
	Dollar dollar = (Dollar) object;
	return amount == dollar.amount;
}
```

일반화를 거친 후 테스트가 성공하고, 할일 목록에서 지운다.

---

### **삼각측량을 언제 사용할까?**

- times() 를 일반화할 때도 삼각측량을 이용할 수 있었다.
    - $5 x 2 = 10 과 $5 x 3 = $15 를 가지고 있었다면 상수를 되돌리는 것만으로 테스트를 통과할 방법은 없었을 것이다.
- ~~삼각측량은 조금 이상한 면이 있다.(?)~~ 어떻게 리팩토링해야 하는지 전혀 감이 안 올 때만 삼각측량을 사용하자.
    - **삼각측량 사용 X:** 만약 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그 방법 그대로 구현한다.
    - **삼각측량 사용 O**: 설계를 어떻게 할지 떠오르지 않을 때 쓰면 좋다. 지금 설계하는 프로그램이 어떤 변화 가능성을 지원해야 하는가? 삼각측량을 사용해 몇몇 부분을 변경시켜보면 답이 더 명확해질 것이다.

**summary**

- 동일성 문제는 해결했지만, null 값이나 다른 객체들과의 비교는 고려하지 않았다. 할일 목록에 적어두자.
- 동질성 기능 구현을 통해 Dollar 와 Dollar 를 직접 비교할 수 있게 됐다.
- 이에 모든 인스턴스 변수들이 그렇듯이 amount를 private으로 만들 수 있게 됐다.

**이번 장에서의 테스트 주기**

- 우리의 디자인 패턴 (값 객체)이 하나의 또 다른 오퍼레이션 (`equals()`) 를 암시한다는 것을 알아챘다.
- 해당 오퍼레이션을 테스트했다.
- 해당 오퍼레이션을 간단히 구현했다.
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다. (삼각측량 사용)
- 두 경우를 모두 수용할 수 있도록 리팩토링했다.